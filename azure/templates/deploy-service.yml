parameters:
  - name: proxy_path
  - name: product_display_name
  - name: product_description
  - name: service_name
  - name: stage_name
  - name: short_service_name
  - name: fully_qualified_service_name
  - name: apigee_environment
  - name: apigee_organization
  - name: service_base_path
  - name: pr_label
  - name: hosted_target_connection_path_suffix
  - name: hosted_target_healthcheck_suffix
  - name: aws_account
    values:
      - ptl
      - prod
  - name: jinja_templates
    type: object
  - name: enable_monitoring
    type: boolean
  - name: enable_status_monitoring
    type: boolean
  - name: ping
    type: boolean
  - name: pre_template
    type: stepList
  - name: post_template
    type: stepList
  - name: pre_deploy
    type: stepList
  - name: post_deploy
    type: stepList
  - name: spec_file
  - name: friendly_api_name
    default: ''
  - name: portal_api_requires_callback_url
    type: boolean
  - name: make_spec_visible
    type: boolean

steps:
  - bash: |
      ls -R
      if [[ -f ecs-deploy-${{ parameters.apigee_environment }}.yml ]] || [[ -f ecs-proxies-deploy.yml ]] || [[ -f ecs-proxies-deploy-sandbox.yml ]]; then
        echo "##vso[task.setvariable variable=deploy_containers]true"
      else
        echo "##vso[task.setvariable variable=deploy_containers]false"
      fi
    workingDirectory: "$(SERVICE_DIR)"
    displayName: "Check for ECS proxy definitions"

  - task: s3-cache-action@1
    inputs:
      key: poetry | utils | $(UTILS_DIR)/poetry.lock
      location: "$(UTILS_DIR)/.venv"
      debug: true
      alias: 'UtilsPreReq'
    displayName: cache utils pre-requisites

  - bash: |
      n=0
      until [ "$n" -ge 3 ]
      do
        make install && break
        n=$((n+1))
      done
    workingDirectory: "$(UTILS_DIR)"
    condition: ne(variables['CacheRestored-UtilsPreReq'], 'true')
    displayName: "Install utils pre-requisites"

  - bash: |
      tfenv use 0.14.6
    displayName: setup terraform
    condition: and(succeeded(), eq(variables['deploy_containers'], 'true'))

  - bash: |
      echo "Deploying ${{ parameters.service_name }} artifact $(SERVICE_ARTIFACT_NAME) as ${{ parameters.fully_qualified_service_name }} to ${{ parameters.service_base_path }} on $(ENV_URL)"
    displayName: 'Deploy Info'

  - ${{ each pre_template_step in parameters.pre_template }}:
    - ${{ pre_template_step }}

  - ${{ if parameters.jinja_templates }}:
      - bash: mkdir -p group_vars/all && touch jinja_templates.yml
        workingDirectory: "$(UTILS_DIR)/ansible/"
        displayName: Prepare extra template-proxy vars

      - ${{ each jinja_template in parameters.jinja_templates }}:
        - bash: 'echo "${{ jinja_template.key }}: ${{ jinja_template.value }}" >> jinja_templates.yml'
          workingDirectory: "$(UTILS_DIR)/ansible/group_vars/all"
          displayName: "Set ${{ jinja_template.key }} to ${{ jinja_template.value }}"

  - bash: |
      set -euo pipefail

      export SERVICE_NAME="${{ parameters.service_name }}"
      export PROXIES_DIR="$(SERVICE_DIR)/proxies"
      export SERVICE_BASE_PATH="${{ parameters.service_base_path }}"
      export APIGEE_ENVIRONMENT="${{ parameters.apigee_environment }}"
      export HOSTED_TARGET_CONNECTION_PATH_SUFFIX="${{ parameters.hosted_target_connection_path_suffix }}"
      export HOSTED_TARGET_HEALTHCHECK_SUFFIX="${{ parameters.hosted_target_healthcheck_suffix }}"
      export SOURCE_COMMIT_ID=$(Build.SourceVersion)
      export RELEASE_RELEASEID=$(Build.BuildId)

      if [[ $SERVICE_ARTIFACT_NAME == v* ]]; then
        export DEPLOYED_VERSION=`echo $SERVICE_ARTIFACT_NAME | grep -o "v[0-9]\+\.[0-9]\+\.[0-9]\+-[[:alpha:]]\+" | tail -1`
      else
        export DEPLOYED_VERSION="${{ parameters.fully_qualified_service_name }}"
      fi

      if [ -f  $(SERVICE_DIR)/.build_env_vars ]; then
        source $(SERVICE_DIR)/.build_env_vars
      fi

      cd $(UTILS_DIR)
      ANSIBLE_FORCE_COLOR=yes \
      make --no-print-directory -C ansible template-proxies

      if [ -f $(SERVICE_DIR)/manifest.yml ]; then
          DIST_DIR=$(SERVICE_DIR) \
          PROXY_DIR=${{ parameters.proxy_path }} \
          ANSIBLE_FORCE_COLOR=yes \
          make --no-print-directory -C ansible add-apim-guids-policy
      fi

    displayName: Template proxies

  - ${{ each post_template_step in parameters.post_template }}:
    - ${{ post_template_step }}

  - ${{ each pre_deploy_step in parameters.pre_deploy }}:
    - ${{ pre_deploy_step }}

  - bash: |
      set -e

      proxy_vars_file=""

      if [ -f  $(SERVICE_DIR)/ecs-deploy-${{ parameters.apigee_environment }}.yml ]; then
        proxy_vars_file="$(SERVICE_DIR)/ecs-deploy-${{ parameters.apigee_environment }}.yml"
      else
        if [ -f  $(SERVICE_DIR)/ecs-deploy-all.yml ]; then
          proxy_vars_file="$(SERVICE_DIR)/ecs-deploy-all.yml"
        fi
      fi
      deploy_role=""

      if [[ ! -z "${proxy_vars_file}" ]]; then
        source $(SERVICE_DIR)/.build_env_vars
        deploy_role="deploy-${{ parameters.apigee_environment }}-${service_id}"

        account=${{ parameters.aws_account }} \
        SERVICE_BASE_PATH=${{ parameters.service_base_path }} \
        APIGEE_ENVIRONMENT=${{ parameters.apigee_environment }} \
        make --no-print-directory  -C $(UTILS_DIR)/ansible create-api-deployment-pre-reqs

      fi

      echo "##vso[task.setvariable variable=PROXY_VARS_FILE]${proxy_vars_file}"
      echo "##vso[task.setvariable variable=DEPLOY_ROLE]${deploy_role}"

    displayName: Create ECS Prerequisites
    condition: and(succeeded(), eq(variables['deploy_containers'], 'true'))

  - template: ../components/aws-assume-role.yml
    parameters:
      role: "$(DEPLOY_ROLE)"
      profile: "$(DEPLOY_ROLE)"
      aws_account: "${{ parameters.aws_account }}"

  - bash: |
      set -e
      proxy_vars_file="$(PROXY_VARS_FILE)"

      source $(SERVICE_DIR)/.build_env_vars

      if [[ $SERVICE_ARTIFACT_NAME == v* ]]; then
        export DEPLOYED_VERSION=`echo $SERVICE_ARTIFACT_NAME | grep -o "v[0-9]\+\.[0-9]\+\.[0-9]\+-[[:alpha:]]\+" | tail -1`
      else
        export DEPLOYED_VERSION="${{ parameters.fully_qualified_service_name }}"
      fi

      account=${{ parameters.aws_account }} \
      PROXY_VARS_FILE="${proxy_vars_file}" \
      SOURCE_COMMIT_ID="$(Build.SourceVersion)" \
      RELEASE_RELEASEID="$(Build.BuildId)" \
      SERVICE_BASE_PATH=${{ parameters.service_base_path }} \
      APIGEE_ENVIRONMENT=${{ parameters.apigee_environment }} \
      make --no-print-directory  -C $(UTILS_DIR)/ansible deploy-ecs-proxies

    displayName: Deploy ECS proxies
    condition: and(succeeded(), ne(variables['DEPLOY_ROLE'], ''))

  - bash: |
      declare -A FRIENDLY_ENV_NAMES=( ["prod"]="(Production)" \
                                      ["sandbox"]="(Sandbox)" \
                                      ["int"]="(Integration Testing)" \
                                      ["dev"]="(Development)" \
                                      ["ref"]="(Reference)" \
                                      ["internal-qa"]="(Internal QA)" \
                                      ["internal-qa-sandbox"]="(Internal QA Sandbox)" \
                                      ["internal-dev"]="(Internal Development)" \
                                      ["internal-dev-sandbox"]="(Internal Development Sandbox)" \
                                    )
      export FRIENDLY_ENV="${FRIENDLY_ENV_NAMES["${{ parameters.apigee_environment }}"]}"

      if [ -z "${{ parameters.friendly_api_name }}" ]; then
        export API_NAME="${{ parameters.fully_qualified_service_name }} ${FRIENDLY_ENV}"
      else
        export API_NAME="${{ parameters.friendly_api_name }} ${FRIENDLY_ENV}"
      fi

      echo "Setting friendly name of: $API_NAME"

      echo "##vso[task.setvariable variable=FRIENDLY_NAME]$API_NAME"
    displayName: "Set Portal API Friendly Name"

  - bash: |
      set -euo pipefail

      export PROXY_DIR="$(SERVICE_DIR)/proxies/${{ parameters.proxy_path }}"
      export SERVICE_NAME="${{ parameters.service_name }}"
      export FULLY_QUALIFIED_SERVICE_NAME="${{ parameters.fully_qualified_service_name }}"
      export SERVICE_BASE_PATH="${{ parameters.service_base_path }}"
      export APIGEE_ACCESS_TOKEN="$(secret.AccessToken)"
      export PRODUCT_DISPLAY_NAME="${{ parameters.product_display_name }}"
      export PRODUCT_DESCRIPTION="${{ parameters.product_description }}"
      export APIGEE_ENVIRONMENT="${{ parameters.apigee_environment }}"
      export APIGEE_ORGANIZATION="nhsd-${{ parameters.apigee_organization }}"
      export RELEASE_RELEASEID="$(Build.BuildId)"
      export PING="${{ parameters.ping }}"
      export ANSIBLE_FORCE_COLOR=yes

      make --no-print-directory -C $(UTILS_DIR)/ansible deploy-apigee-proxy

      if [ -f $(SERVICE_DIR)/manifest.yml ]; then
          export DIST_DIR=$(SERVICE_DIR)
          export PULL_REQUEST="${{ parameters.pr_label }}"
          make --no-print-directory -C $(UTILS_DIR)/ansible deploy-manifest
      else
          if [[ ! -z "${PRODUCT_DISPLAY_NAME}" ]]; then
              if [[ -n "${{ parameters.spec_file }}" ]]; then
                  export SPEC_FILE="$(SERVICE_DIR)/${{ parameters.spec_file }}"
              fi
              export FRIENDLY_NAME="$(FRIENDLY_NAME)"
              export VISIBLE="${{ parameters.make_spec_visible }}"
              export REQUIRE_CALLBACK_URL="${{ parameters.portal_api_requires_callback_url }}"
              make --no-print-directory -C $(UTILS_DIR)/ansible deploy-apigee-product-and-spec
          fi
      fi
    displayName: 'Deploy Proxy, Product and Spec'

  - bash: |
      set -euo pipefail

      echo "Setting stage name as snake case for monitoring"
      export MONITORING_STAGE_NAME="${{ replace(parameters.stage_name, '_', '-') }}"
      echo "MONITORING_STAGE_NAME=${MONITORING_STAGE_NAME}"
      echo "##vso[task.setvariable variable=MONITORING_STAGE_NAME]$MONITORING_STAGE_NAME"

      if [[ "${{ parameters.apigee_environment }}" == "prod" ]]; then
        export url="https://api.service.nhs.uk/monitoring-sd/service"
        export status_body='{ "${{ parameters.service_name }}": { "${{ parameters.apigee_environment }}": [ "${{ parameters.service_name }}@$(MONITORING_STAGE_NAME)=http_2xx_with_api_key https://api.service.nhs.uk/${{ parameters.service_base_path }}/_status" ] } }'
        export ping_body='{ "${{ parameters.service_name }}": { "${{ parameters.apigee_environment }}": [ "${{ parameters.service_name }}@$(MONITORING_STAGE_NAME)=http_2xx https://api.service.nhs.uk/${{ parameters.service_base_path }}/_ping" ] } }'
      else
        export url="https://internal-dev.api.service.nhs.uk/monitoring-sd/service"
        export status_body='{ "${{ parameters.service_name }}": { "${{ parameters.apigee_environment }}": [ "${{ parameters.service_name }}@$(MONITORING_STAGE_NAME)=http_2xx_with_api_key https://${{ parameters.apigee_environment }}.api.service.nhs.uk/${{ parameters.service_base_path }}/_status" ] } }'
        export ping_body='{ "${{ parameters.service_name }}": { "${{ parameters.apigee_environment }}": [ "${{ parameters.service_name }}@$(MONITORING_STAGE_NAME)=http_2xx https://${{ parameters.apigee_environment }}.api.service.nhs.uk/${{ parameters.service_base_path }}/_ping" ] } }'
      fi

      echo "##vso[task.setvariable variable=enable_ping_monitoring]${{ parameters.enable_monitoring }}"
      echo "##vso[task.setvariable variable=enable_status_monitoring]${{ parameters.enable_status_monitoring }}"

      if [[ "${{ parameters.service_base_path }}" == *"-pr-"* ]]; then
        echo "##vso[task.setvariable variable=enable_ping_monitoring]false"
        echo "##vso[task.setvariable variable=enable_status_monitoring]false"
      fi

      echo "##vso[task.setvariable variable=url]$url"
      echo "##vso[task.setvariable variable=status_body]$status_body"
      echo "##vso[task.setvariable variable=ping_body]$ping_body"
    displayName: 'Set monitoring variables'


  - bash: |
      set -euo pipefail
    
      if [[ "${{ parameters.apigee_environment }}" == "prod" ]]; then
        export ping_endpoint_response=`curl -s -o /dev/null -w '%{http_code}' -H "apikey: $(status-endpoint-api-key)" https://api.service.nhs.uk/${{ parameters.service_base_path }}/_ping`
      else
        export ping_endpoint_response=`curl -s -o /dev/null -w '%{http_code}' -H "apikey: $(status-endpoint-api-key)" https://${{ parameters.apigee_environment }}.api.service.nhs.uk/${{ parameters.service_base_path }}/_ping`
      fi

      echo _ping_response=$ping_endpoint_response
      echo "##vso[task.setvariable variable=ping_endpoint_response]$ping_endpoint_response"
    
      if [[ $(ping_endpoint_response) != "200" ]]; then
        echo "##vso[task.logissue type=error]Your proxy doesn't have a _ping endpoint therefore we can't monitor this proxy and it should not be released, use the flag 'enable_monitoring=false' if your API doesn't support _ping healthcheck."
        echo "##vso[task.setvariable variable=enable_ping_monitoring]false"
        exit 1       
      fi 
    displayName: 'Check _ping'
    condition: eq(variables['enable_ping_monitoring'], 'true')
 
  - bash: |
      set -euo pipefail
      
      if [[ "${{ parameters.apigee_environment }}" == "prod" ]]; then
        export status_endpoint_response=`curl -s -o /dev/null -w '%{http_code}' -H "apikey: $(status-endpoint-api-key)" https://api.service.nhs.uk/${{ parameters.service_base_path }}/_status`
      else
        export status_endpoint_response=`curl -s -o /dev/null -w '%{http_code}' -H "apikey: $(status-endpoint-api-key)" https://${{ parameters.apigee_environment }}.api.service.nhs.uk/${{ parameters.service_base_path }}/_status`
      fi

      echo _status_response=$status_endpoint_response
      echo "##vso[task.setvariable variable=status_endpoint_response]$status_endpoint_response"
      
      if [[ $(status_endpoint_response) != "200" ]]; then
        echo "##vso[task.logissue type=error]Your proxy doesn't have a _status endpoint therefore we can't monitor this proxy and it should not be released, use the flag 'enable_status_monitoring=false' if your API doesn't support _status healthcheck."
        echo "##vso[task.setvariable variable=enable_status_monitoring]false"
        exit 1            
      fi
      
    displayName: 'Check _status'
    condition: eq(variables['enable_status_monitoring'], 'true')

  - bash: |
      set -euo pipefail

      curl --fail -X 'POST' -H 'apikey: $(MONITORING_API_KEY)' -d '$(status_body)' $(url)
    displayName: Enable _status monitoring
    condition: eq(variables['enable_status_monitoring'], 'true')

  - bash: |
      set -euo pipefail

      curl --fail -X 'DELETE' -H 'apikey: $(MONITORING_API_KEY)' -d '$(status_body)' $(url)
      echo
      echo "_status endpoint monitoring is disabled"
    displayName: Disable _status monitoring
    condition: eq(variables['enable_status_monitoring'], 'false')

  - bash: |
      set -euo pipefail

      curl --fail -X 'POST' -H 'apikey: $(MONITORING_API_KEY)' -d '$(ping_body)' $(url)
    displayName: Enable _ping monitoring
    condition: eq(variables['enable_ping_monitoring'], 'true')

  - bash: |
      set -euo pipefail

      curl --fail -X 'DELETE' -H 'apikey: $(MONITORING_API_KEY)' -d '$(ping_body)' $(url)
      echo
      echo "_ping endpoint monitoring is disabled"
    displayName: Disable _ping monitoring
    condition: eq(variables['enable_ping_monitoring'], 'false')

  - ${{ each post_deploy_step in parameters.post_deploy }}:
    - ${{ post_deploy_step }}